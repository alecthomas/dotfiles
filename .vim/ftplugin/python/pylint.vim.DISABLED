" pylint.vim - A script to highlight Python code on the fly with warnings
" from Pylint, a Python lint tool.
"
" Place this script and the accompanying pylint directory in
" .vim/ftplugin/python.
"
" See README for additional installation and information.
"
" Thanks to matlib.vim for ideas/code on interactive linting.
"
" Maintainer: Kevin Watters <kevin.watters@gmail.com>
" Version: 0.1

if exists("b:did_pylint_plugin")
    finish " only load once
else
    let b:did_pylint_plugin = 1
endif

if !exists('g:pylint_builtins')
    let g:pylint_builtins = []
endif

if !exists("b:did_python_init")
    python << EOF
import vim
import os.path
import sys
import tempfile

from pylint import checkers
from pylint import interfaces
from pylint import reporters
from pylint import lint

from operator import attrgetter

class VimReporter(reporters.BaseReporter):
    class Message(object):
        def __init__(self, msg_id, location, message):
            self.lineno = location[3]
            self.message = msg_id + ' ' + message
            self.message_args = ()
            # It would be nice to get column information out of pylint :(
            self.col = None

    __implements__ = interfaces.IReporter

    def __init__(self):
        reporters.BaseReporter.__init__(self)
        self.messages = []

    def add_message(self, msg_id, location, msg):
        self.messages.append(VimReporter.Message(msg_id, location, msg))

    def display_results(self, layout):
        pass

class blackhole(object):
    write = flush = lambda *a, **k: None

def check(buffer):
    filename = buffer.name
    contents = '\n'.join(buffer[:])

    if not contents.strip():
        return []

        # builtins = []
        # try:
        # builtins = eval(vim.eval('string(g:pylint_builtins)'))
        # except Exception:
        # pass

    reporter = VimReporter()
    linter = lint.PyLinter(reporter=reporter)
    checkers.initialize(linter)
    linter.load_config_file()

    try:
        # TODO: use warnings filters instead of ignoring stderr
        old_stderr, sys.stderr = sys.stderr, blackhole()
        try:
            fd, name = tempfile.mkstemp(suffix='.py')
            try:
                os.write(fd, contents)
                os.close(fd)
                linter.check([name])
            finally:
                os.unlink(name)
        finally:
            sys.stderr = old_stderr
    except:
        # TODO(aat) Figure out why handling SyntaxError below is failing
        return []
        try:
            value = sys.exc_info()[1]
            lineno, offset, line = value[1][1:]
        except IndexError:
            lineno, offset, line = 1, 0, ''
        if line.endswith("\n"):
            line = line[:-1]

        return [SyntaxError(filename, lineno, offset, str(value))]
    else:
        reporter.messages.sort(key = attrgetter('lineno'))
        return reporter.messages


def vim_quote(s):
    return s.replace("'", "''")
EOF
    let b:did_python_init = 1
endif

function s:PylintEnable()
    let b:pylint_enabled = 1

    aug Pylint
        au Pylint BufLeave <buffer> call s:ClearPylint()

        au Pylint BufEnter <buffer> call s:RunPylint()
        au Pylint InsertLeave <buffer> call s:RunPylint()
        au Pylint InsertEnter <buffer> call s:RunPylint()
        au Pylint BufWritePost <buffer> call s:RunPylint()

        au Pylint CursorHold <buffer> call s:RunPylint()
        au Pylint CursorHoldI <buffer> call s:RunPylint()

        au Pylint CursorHold <buffer> call s:GetPylintMessage()
        au Pylint CursorMoved <buffer> call s:GetPylintMessage()
    aug END
endfunction

function s:PylintDisable()
    let b:pylint_enabled = 0
    aug! Pylint
    call s:ClearPylint()
endfunction

function s:PylintToggle()
    if b:pylint_enabled == 1
        call s:PylintDisable()
    else
        call s:PylintEnable
    endif
endfunction

call s:PylintEnable()

if !exists("*s:PylintUpdate")
    function s:PylintUpdate()
        silent call s:RunPylint()
        call s:GetPylintMessage()
    endfunction
endif

" Call this function in your .vimrc to update PyLint
if !exists(":PylintUpdate")
  command PylintUpdate :call s:PylintUpdate()
  command PylintToggle :call s:PylintToggle()
  command PylintEnable :call s:PylintEnable()
  command PylintDisable :call s:PylintDisable()
endif

" Hook common text manipulation commands to update PyLint
"   TODO: is there a more general "text op" autocommand we could register
"   for here?
"noremap <buffer><silent> dd dd:PylintUpdate<CR>
"noremap <buffer><silent> dw dw:PylintUpdate<CR>
"noremap <buffer><silent> u u:PylintUpdate<CR>
"noremap <buffer><silent> <C-R> <C-R>:PylintUpdate<CR>

" WideMsg() prints [long] message up to (&columns-1) length
" guaranteed without "Press Enter" prompt.
if !exists("*s:WideMsg")
    function s:WideMsg(msg)
        let x=&ruler | let y=&showcmd
        set noruler noshowcmd
        redraw
        echo a:msg
        let &ruler=x | let &showcmd=y
    endfun
endif

if !exists("*s:RunPylint")
    function s:RunPylint()
        highlight link PyLint SpellBad

        if exists("b:cleared")
            if b:cleared == 0
                silent call s:ClearPylint()
                let b:cleared = 1
            endif
        else
            let b:cleared = 1
        endif
        
        let b:matched = []
        let b:matchedlines = {}
        python << EOF
for w in check(vim.current.buffer):
    vim.command('let s:matchDict = {}')
    vim.command("let s:matchDict['lineNum'] = " + str(w.lineno))
    vim.command("let s:matchDict['message'] = '%s'" % vim_quote(w.message % w.message_args))
    vim.command("let b:matchedlines[" + str(w.lineno) + "] = s:matchDict")

    if w.col is None or isinstance(w, SyntaxError):
        # without column information, just highlight the whole line
        # (minus the newline)
        vim.command(r"let s:mID = matchadd('PyLint', '\%" + str(w.lineno) + r"l\n\@!')")
    else:
        # with a column number, highlight the first keyword there
        vim.command(r"let s:mID = matchadd('PyLint', '^\%" + str(w.lineno) + r"l\_.\{-}\zs\k\+\k\@!\%>" + str(w.col) + r"c')")

    vim.command("call add(b:matched, s:matchDict)")
EOF
        let b:cleared = 0
    endfunction
end

" keep track of whether or not we are showing a message
let b:showing_message = 0

if !exists("*s:GetPylintMessage")
    function s:GetPylintMessage()
        let s:cursorPos = getpos(".")

        " Bail if RunPylint hasn't been called yet.
        if !exists('b:matchedlines')
            return
        endif

        " if there's a message for the line the cursor is currently on, echo
        " it to the console
        if has_key(b:matchedlines, s:cursorPos[1])
            let s:pylintMatch = get(b:matchedlines, s:cursorPos[1])
            call s:WideMsg(s:pylintMatch['message'])
            let b:showing_message = 1
            return
        endif

        " otherwise, if we're showing a message, clear it
        if b:showing_message == 1
            echo
            let b:showing_message = 0
        endif
    endfunction
endif

if !exists('*s:ClearPylint')
    function s:ClearPylint()
        let s:matches = getmatches()
        for s:matchId in s:matches
            if s:matchId['group'] == 'PyLint'
                call matchdelete(s:matchId['id'])
            endif
        endfor
        let b:matched = []
        let b:matchedlines = {}
        let b:cleared = 1
    endfunction
endif

